#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jul 20 9:35 2020

@author: MCR

File containing the necessary functions to create an empirical
interpolated trace model in the overlap region for SOSS order 1.
"""

import os
import numpy as np
from astropy.io import fits
import matplotlib.pyplot as plt
import webbpsf
from SOSS.trace import tracepol as tp
from SOSS.extract.empirical_trace import _centroid as ctd
from SOSS.extract.overlap import TrpzOverlap, TrpzBox
from SOSS.extract.throughput import ThroughputSOSS
from SOSS.extract.convolution import WebbKer


def build_empirical_trace(clear, F277W, filename='spatial_profile.fits',
                          doplot=False, pad_factor=1):
    ''' Procedural function to wrap around construct orders 1 and 2.
    Will do centroiding and call the functions to construct the models.

    ***Will eventually want clear and F277W to be the full fits with headers
    to get parameters from***

    Parameters
    ----------
    clear : np.array of float (2D) - eventually path
    F277W : np.array of float (2D) - eventually path
    filename : str
    doplot : bool
    '''

    # Print overwrite warning if output file already exists.
    if os.path.exists(filename):
        print('Output file {} already exists. It will be overwritten'.format(filename))
    # Get the centroid positions for both orders from the data.
    centroids, rot_pars = ctd.get_contam_centroids(clear, doplot=doplot)

    # Overplot the data centroids on the CLEAR exposure if desired.
    if doplot is True:
        _plot_centroid(clear, centroids)

    # Construct the first order profile.
    o1frame_contam = construct_order1(clear, F277W, rot_pars)
    # Create a mask to remove the second order from the CLEAR data.
    o1frame = mask_order(o1frame_contam, centroids['order 1'][0],
                         centroids['order 1'][1])
    # Set any spurious negative values to zero.
    o1frame[o1frame < 0] = 0
    # Normalize the profile in each column.
    o1frame /= np.nansum(o1frame, axis=0)
    # Reconstruct extended wing structure, and add spatial axis padding.
    o1frame = reconstruct_wings(o1frame, centroids['order 1'][1],
                                pad_factor=pad_factor)

    # Get the extraction parameters
    #extract_params = get_extract_params()
    #ref_file_args = get_ref_file_args(o1frame)
    # Construct the second order profile.
    #o2frame_contam = construct_order2(clear, ref_file_args, extract_params)
    # Create a mask to remove residuals from the first order.
    #o2frame = mask_order(o2frame_contam, x2, y2)
    # Set any spurious negative values to zero.
    #o2frame[o2frame < 0] = 0
    # Normalize the profile in each column.
    #o2frame /= np.nansum(o2frame, axis=0)

    # Write the trace model to disk.
    #hdu = fits.PrimaryHDU()
    #hdu.data = np.dstack((o1frame, o2frame))
    #hdu.writeto(filename, overwrite=True)

    return o1frame#, o2frame


def calc_interp_coefs(make_psfs=False, doplot=True, F277W=True, filepath=''):
    '''Function to calculate the interpolation coefficients necessary to
    construct a monochromatic PSF profile at any wavelength between
    the two 1D PSF anchor profiles. Linear combinations of the blue and red
    anchor are iteratively fit to each intermediate wavelength to find the
    best fitting combination. The mean linear coefficients across the 10 WFE
    error realizations are returned for each wavelengths.
    When called, 2D moncochromatic PSF profiles will be generated and saved
    to disk if the user does not already have them available.
    This should not need to be called by the end user except in rare cases.

    Parameters
    ----------
    make_psfs : bool
        Whether or not WebbPSF will have to generate the monochromatic
        PSFs used for the fitting.
    doplot : bool
        Whether to show the diagnostic plots for the model derivation.
    F277W : bool
        Set to False if no F277W exposure is available for the observation.
        Finds coefficients for the entire 2.2 - 2.8µm region in this case.
    filepath : str
        Path to directory containing the WebbPSF monochromatic PSF fits
        files, or the directory to which they will be stored when made.
        Defaults to the current directory.

    Returns
    -------
    pb : np.array of float
        Polynomial coefficients of the interpolation index fits for the
        blue anchor.
    pr : np.array of float
        Polynomial coefficients of the interpolation index fits for the
        red anchor.
    '''

    # Red anchor is 2.8µm without an F277W exposure.
    if F277W is False:
        wave_range = np.linspace(2.1, 2.85, 7)
    # Red anchor is 2.5µm with F277W exposure.
    else:
        wave_range = np.linspace(2.1, 2.42, 7)

    # Read in monochromatic PSFs generated by WebbPSF.
    PSFs = []
    # Loop over all 10 available WFE realizations.
    for i in range(10):
        psf_run = []
        # Create the PSF if user has indicated to.
        if make_psfs is True:
            loicpsf(wavelist=wave_range*1e-6, wfe_real=i)
        # If user already has PSFs generated.
        for w in wave_range:
            try:
                psf_run.append(fits.open('{0:s}SOSS_os10_128x128_{1:.6f}_{2:.0f}.fits'
                                         .format(filepath, w, i))[0].data)
            # Generate missing PSFs if necessary.
            except FileNotFoundError:
                print('No monochromatic PSF found for {0:.2f}µm and WFE realization {1:.0f}.'
                      .format(w, i))
                loicpsf(wavelist=[w*1e-6], wfe_real=i, filepath=filepath)
                psf_run.append(fits.open('{0:s}SOSS_os10_128x128_{1:.6f}_{2:.0f}.fits'
                                         .format(filepath, w, i))[0].data)
        PSFs.append(psf_run)

    # Determine specific interpolation coefficients for all WFEs
    wb, wr = [], []

    for E in range(10):
        # Generate the blue wavelength anchor.
        # The width of the 1D PSF has lambda/D dependence, so rescale all
        # profiles to a common wavelength to remove these chromatic effects.
        rngeb = np.linspace(0, round(1280*(2.5/2.1), 0) - 1, 1280)
        offsetb = rngeb[640] - 640
        newb = np.interp(np.arange(1280), rngeb - offsetb,
                         np.sum(PSFs[E][0][600:700, :], axis=0))

        # Generate the red wavelength anchor.
        if F277W is False:
            # Use 2.85µm for CLEAR.
            rnger = np.linspace(0, round(1280*(2.5/2.85), 0) - 1, 1280)
        else:
            # Or 2.42µm for F277W.
            rnger = np.linspace(0, round(1280*(2.5/2.42), 0) - 1, 1280)
        offsetr = rnger[640] - 640
        # Remove lambda/D scaling.
        newr = np.interp(np.arange(1280), rnger - offsetr,
                         np.sum(PSFs[E][6][600:700, :], axis=0))

        # Loop over all monochrmatic PSFs to determine interpolation coefs.
        for f, wave in enumerate(wave_range):
            # Lists for running counts of indicies and model residuals.
            resid, ind_i, ind_j = [], [], []

            # Rescale monochrmotic PSF to remove lambda/D.
            newrnge = np.linspace(0, round(1280*(2.5/wave), 0) - 1, 1280)
            newoffset = newrnge[640] - 640
            newpsf = np.interp(np.arange(1280), newrnge - newoffset,
                               np.sum(PSFs[E][f][600:700, :], axis=0))

            # Brute force the coefficient determination.
            for i in range(1, 100):
                for j in range(1, 100):
                    i /= 10
                    j /= 10
                    # Create a test profile which is a mix of the two anchors.
                    mix = (i*newb + j*newr) / (i + j)

                    # Save current iteration in running counts.
                    resid.append(np.sum(np.abs(newpsf - mix)[450:820]))
                    ind_i.append(i)
                    ind_j.append(j)

            # Determine which combination of indices minimizes model residuals.
            ind = np.where(resid == np.min(resid))[0][0]
            # Save the normalized indices for this wavelength.
            wb.append(ind_i[ind] / (ind_i[ind] + ind_j[ind]))
            wr.append(ind_j[ind] / (ind_i[ind] + ind_j[ind]))

    wb = np.reshape(wb, (10, 7))
    wr = np.reshape(wr, (10, 7))

    # Fit a second order polynomial to the mean of the interpolation indices.
    pb = np.polyfit(wave_range, np.mean(wb, axis=0), 2)
    pr = np.polyfit(wave_range, np.mean(wr, axis=0), 2)

    # Show the diagnostic plot if necessary.
    if doplot is True:
        _plot_interpmodel(wave_range, wb, wr, pb, pr)

    return pb, pr, wb, wr


def _chromescale(wave, profile, invert=False):
    '''Utility function to remove the lambda/D chromatic PSF scaling by
    interpolating a monochromatic PSF function onto a standard axis.

    Parameters
    ----------
    wave : float
        Wavelength corresponding to the input 1D PSF profile.
    profile : np.array of float
        1D PSF profile to be rescaled.
    invert : bool
        If True, add back the lambda/D scaling instead of removing it.

    Returns
    -------
    new : np,.array of float
        Rescaled 1D PSF profile.
    '''

    # Create the standard axis
    rnge = np.linspace(0, round(49*(2.5/wave), 0) - 1, 49)
    offset = rnge[24] - 24

    # Interpolate the profile onto the standard axis.
    if invert is False:
        new = np.interp(np.arange(49), rnge - offset, profile)
    # Or interpolate the profile from the standard axis to re-add
    # the lambda/D scaling.
    else:
        new = np.interp(rnge - offset, np.arange(49), profile)

    return new


def construct_order1(clear, F277, rot_params):
    '''This creates the full order 1 trace profile model. The region
    contaminated by the second order is interpolated from the CLEAR and F277W
    exposures, or just from the CLEAR exposure and a standard red anchor if
    no F277W exposure is available.
    The steps are as follows:
        1. Determine the red and blue anchor profiles for the interpolation.
        2. Construct the interpolated profile at each wavelength in the
           overlap region.
        3. Stitch together the original CLEAR exposure and the interpolated
           trace model (as well as the F277W exposure if provided).

    Parameters
    ----------
    clear : np.array of float (2D)
        NIRISS SOSS CLEAR exposure dataframe.
    F277 : np.array of float (2D)
        NIRISS SOSS F277W filter exposure dataframe. If no F277W exposure
        is available, pass None.
    rot_params : list of float
        List containing the rotation angle, X and Y anchor points, and X
        and Y offset required to transform OM coordinates to the detector
        frame.

    Returns
    -------
    newmap : np.array of float (2D)
        Interpolated order 1 trace model.
    '''

    # Determine the anchor profiles - blue anchor.
    # Note: Y-values returned from OM are inverted relative to the UdeM
    # coordinate system.
    xOM, yOM, tp2 = ctd.get_om_centroids()
    # Get OM centroid pixel coords at 2.1µm.
    xom22 = tp.wavelength_to_pix(2.1, tp2, 1)[0]
    yom22 = 256 - tp.wavelength_to_pix(2.1, tp2, 1)[1]
    # Use rot params to find location of the 2.1µm centroids in the data frame.
    xd22, yd22 = ctd.rot_centroids(*rot_params, xom22, yom22)
    xd22 = np.round(xd22, 0).astype(int)[0]
    yd22 = np.round(yd22, 0).astype(int)[0]
    # Extract the 2.1µm anchor profile from the data.
    Banch = clear[(yd22-24):(yd22+25), xd22]
    # Remove the lambda/D scaling.
    Banch = _chromescale(2.1, Banch)
    # Normalize
    Banch /= np.nansum(Banch)

    # Determine the anchor profiles - red anchor.
    if F277 is None:
        # If no F277W exposure is provided, interpolate out to 2.85µm.
        # Generate a simulated 2.85µm PSF.
        stand = loicpsf([2.85*1e-6], save_to_disk=False, oversampling=1,
                        verbose=False)[0][0].data
        # Extract and rescale the spatial profile.
        Ranch = np.sum(stand[60:70, (64-24):(64+25)], axis=0)
        Ranch = _chromescale(2.85, Ranch)
        # Normalize
        Ranch /= np.nansum(Ranch)

        # Interpolation polynomial coeffs, calculated via calc_interp_coefs
        coef_b = [0.86772837, -5.6445105, 9.03072711]
        coef_r = [-0.86772837, 5.6445105, -8.03072711]
        # Pixel coords at which to start and end interpolation in OM frame.
        end = int(round(tp.wavelength_to_pix(2.1, tp2, 1)[0], 0))
        # Determine the OM coords of first pixel on detector
        start = int(round(tp.wavelength_to_pix(2.85, tp2, 1)[0], 0))
        rlen = end - start

    else:
        # If an F277W exposure is provided, only interpolate out to 2.42µm.
        # Redwards of 2.42µm we have perfect knowledge of the order 1 trace.
        # Get OM centroid pixel coords at 2.42µm
        xom25 = tp.wavelength_to_pix(2.42, tp2, 1)[0]
        yom25 = 256 - tp.wavelength_to_pix(2.42, tp2, 1)[1]
        # Transform into the data frame.
        xd25, yd25 = ctd.rot_centroids(*rot_params, xom25, yom25)
        xd25 = np.round(xd25, 0).astype(int)[0]
        yd25 = np.round(yd25, 0).astype(int)[0]
        # Extract and rescale the 2.5µm profile.
        Ranch = F277[(yd25-24):(yd25+25), xd25]
        Ranch = _chromescale(2.42, Ranch)
        # Normalize
        Ranch /= np.nansum(Ranch)

        # Interpolation polynomial coeffs, calculated via calc_interp_coefs
        coef_b = [1.79989423, -11.25359201, 16.68929109]
        coef_r = [-1.79989423, 11.25359201, -15.68929109]
        # Pixel coords at which to start and end interpolation in OM frame.
        end = int(round(tp.wavelength_to_pix(2.1, tp2, 1)[0], 0))
        start = int(round(tp.wavelength_to_pix(2.42, tp2, 1)[0], 0))
        rlen = end - start

    # Create the interpolated order 1 PSF.
    map2D = np.zeros((256, 2048))*np.nan
    # Get OM X-pixel values for the region to be interpolated.
    cenx_om = np.arange(rlen) + start
    # Find the wavelength at each X centroid
    lmbda = tp.specpix_to_wavelength(cenx_om, tp2, 1)[0]
    # Y centroid at each wavelength
    ceny_om = 256 - tp.wavelength_to_pix(lmbda, tp2, 1)[1]
    # Transform the OM centroids onto the detector.
    cenx_d, ceny_d = ctd.rot_centroids(*rot_params, cenx_om, ceny_om,
                                       bound=False)

    # Create an interpolated 1D PSF at each required position.
    for i, vals in enumerate(zip(cenx_d, ceny_d, lmbda)):
        cenx, ceny, lbd = vals[0], vals[1], vals[2]
        # Evaluate the interpolation polynomials at the current wavelength.
        wb_i = np.polyval(coef_b, lbd)
        wr_i = np.polyval(coef_r, lbd)
        # Construct the interpolated profile.
        prof_int = (wb_i * Banch + wr_i * Ranch)
        # Re-add the lambda/D scaling.
        prof_int_cs = _chromescale(lbd, prof_int, invert=True)

        # Put the interpolated profile on the detector.
        axis = np.linspace(-24, 24, 49) + ceny
        inds = np.where((axis < 256) & (axis >= 0))[0]
        profile = np.interp(np.arange(256), axis[inds], prof_int_cs[inds])
        map2D[:, int(round(cenx, 0))] = profile

        # Note detector coordinates of the edges of the interpolated region.
        bend = int(round(cenx, 0))
        if i == 0:
            # 2.85µm (i=0) limit may be off the end of the detector.
            rend = np.max([int(round(cenx, 0)), 0])

    # Stitch together the interpolation and data.
    newmap = np.zeros((256, 2048))
    # Insert interpolated data
    newmap[:, rend:bend] = map2D[:, rend:bend]
    # Bluer region is known from the CLEAR exposure.
    newmap[:, bend:2048] = clear[:, bend:2048]
    if F277 is not None:
        # Sdd on the F277W frame to the red of the model.
        newmap[:, 0:rend] = F277[:, 0:rend]
    # Insert interpolated data to the red of the data.
    else:
        newmap[:, 0:rend] = map2D[:, 0:rend]

    return newmap


def construct_order2(clear, ref_file_args, extract_params):
    '''Preforms an extraction and reconstructs the detector with only the
    first order trace profile. The second order profile is then isolated
    through the difference of the original and reconstructed detector.

    Parameters
    ----------
    clear : np.array of float (2D)
        CLEAR data frame.
    ref_file_args : list
        List of parameters of the reference files.
    extract_params : dict
        Dictionary of arguments required by the extraction algorithm.

    Returns
    -------
    residual : np.array of float (2D)
        Detector with only the order 2 trace profile.
    '''

    # Set up the extraction.
    extra = TrpzOverlap(*ref_file_args, **extract_params)
    # Preform the extraction with only the first order.
    f_k = extra.extract(data=clear)
    # Rebuild the detector.
    rebuilt = extra.rebuild(f_k)
    rebuilt[np.isnan(rebuilt)] = 0
    # Isolate the second order by subtracting the reconstructed first
    # order from the data
    residual = clear - rebuilt

    return residual


def get_extract_params():
    '''
    '''
    params = {}
    # Map of expected noise (sig)
    bkgd_noise = 20.
    # Oversampling
    params["n_os"] = 1
    # Threshold on the spatial profile
    params["thresh"] = 1e-6

    return params


def get_ref_file_args(o1frame):
    '''
    '''
    path = '/Users/michaelradica/Documents/GitHub/jwst-mtl/SOSS/'
    # List of orders to consider in the extraction
    order_list = [1]

    # Wavelength solution
    wave_maps = []
    wave_maps.append(fits.getdata(path+"extract/Ref_files/wavelengths_m1.fits"))

    # Spatial profiles
    spat_pros = []
    spat_pros.append(o1frame)

    # Convert data from fits files to float (fits precision is 1e-8)
    wave_maps = [wv.astype('float64') for wv in wave_maps]
    spat_pros = [p_ord.astype('float64') for p_ord in spat_pros]

    # Throughputs
    thrpt_list = [ThroughputSOSS(order) for order in order_list]

    # Convolution kernels
    ker_list = [WebbKer(wv_map) for wv_map in wave_maps]

    # Put all inputs from reference files in a list
    ref_file_args = [spat_pros, wave_maps, thrpt_list, ker_list]

    return ref_file_args


def loicpsf(wavelist=None, wfe_real=None, filepath='', save_to_disk=True,
            oversampling=10, verbose=True):
    '''Calls the WebbPSF package to create monochromatic PSFs for NIRISS
    SOSS observations and save them to disk.

    Parameters
    ----------
    wavelist : list
        List of wavelengths (in meters) for which to generate PSFs.
    wfe_real : int
        Index of wavefront realization to use for the PSF (if non-default
        WFE realization is desired).
    filepath : str
        Path to the directory to which the PSFs will be written.
        Defaults to the current directory.
    save_to_disk : bool
        Whether to save PSFs to disk, or return them from the function.
    oversampling : int
        Oversampling pixels scale for the PSF.
    verbose : bool
        Whether to print explanatory comments.

    Returns
    -------
    psf_list : list
        If save_to_disk is False, a list of the generated PSFs.
    '''

    psf_list = []

    if wavelist is None:
        # List of wavelengths to generate PSFs for
        wavelist = np.linspace(0.5, 5.2, 95) * 1e-6
    # Dimension of the PSF in native pixels
    pixel = 128

    # Select the NIRISS instrument
    niriss = webbpsf.NIRISS()

    # Override the default minimum wavelength of 0.6 microns
    niriss.SHORT_WAVELENGTH_MIN = 0.5e-6
    # Set correct filter and pupil wheel components
    niriss.filter = 'CLEAR'
    niriss.pupil_mask = 'GR700XD'

    # Change the WFE realization if desired
    if wfe_real is not None:
        niriss.pupilopd = ('OPD_RevW_ote_for_NIRISS_predicted.fits.gz',
                           wfe_real)

    # Loop through all wavelengths to generate PSFs
    for wave in wavelist:
        if verbose is True:
            print('Calculating PSF at wavelength ',
                  round(wave/1e-6, 2), ' microns')
        psf = niriss.calc_psf(monochromatic=wave, fov_pixels=pixel,
                              oversample=oversampling, display=False)
        psf_list.append(psf)

        if save_to_disk is True:
            # Save psf realization to disk
            text = '{0:5f}'.format(wave*1e+6)
            psf.writeto(str(filepath)+'SOSS_os'+str(oversampling)+'_'+str(pixel)
                        + 'x'+str(pixel)+'_'+text+'_'+str(wfe_real)+'.fits',
                        overwrite=True)

        if save_to_disk is False:
            return psf_list


def mask_order(frame, xpix, ypix):
    '''Create a pixel mask to isolate only the detector pixels belonging to
     a specific diffraction order.

    Parameters
    ----------
    frame : np.array of float (2D)
        Science data frame.
    xpix : np.array
        Data x centroids for the desired order
    ypix : np.array
        Data y centroids for the desired order

    Returns
    -------
    O1frame : np.array of float (2D)
        The input data frame, with all pixels other than those within
        +/- 20 pixels of ypix masked.
    '''

    mask = np.zeros([256, 2048])
    xx = np.round(xpix, 0).astype(int)
    yy = np.round(ypix, 0).astype(int)
    xr = np.linspace(np.min(xx), np.max(xx), np.max(xx)+1).astype(int)

    # Set all pixels within the extent of the spatial profile to 1
    for xxx, yyy in zip(xr, yy):
        # Ensure that we stay on the detector
        p_max = np.min([yyy+20, 255])
        p_min = np.max([yyy-21, 0])
        mask[p_min:p_max, xxx] = 1

    # Mask pixels not in the order we want
    O1frame = (mask * frame)

    return O1frame


def pad_spectral_axis(frame, xcen, ycen, pad_factor=1):

    newframe = np.zeros((frame.shape[0], frame.shape[1]*pad_factor))
    pp = np.polyfit(xcen, ycen, 5)
    ext_len = frame.shape[1]*pad_factor
    xcen_ext = np.arange(ext_len) - (ext_len - frame.shape[1])/2
    ycen_ext = np.polyval(pp, xcen_ext)

    start = int((frame.shape[1]/2)*(pad_factor-1))
    end = int(start+frame.shape[1])
    newframe[:, start:end] = frame

    for col in reversed(range(start)):
        ref = newframe[:, start]
        ax = np.arange(frame.shape[0])
        newax = ax + (ycen_ext[col] - ycen_ext[start])
        newcol = np.interp(ax, newax, ref)
        newframe[:, col] = newcol

    for col in range(end, frame.shape[1]*pad_factor):
        ref = newframe[:, end-1]
        ax = np.arange(frame.shape[0])
        newax = ax + (ycen_ext[col] - ycen_ext[end-1])
        newcol = np.interp(ax, newax, ref)
        newframe[:, col] = newcol

    return newframe


def _plot_centroid(clear, centroid_dict):
    '''Utility function to overplot the trace centroids extracted from
    the data over the data itself to verify accuracy.
    '''
    plt.figure(figsize=(15, 3))
    for order in centroid_dict.keys():
        plt.plot(centroid_dict[order][0], centroid_dict[order][1], c='black')
    plt.imshow(clear/np.nansum(clear, axis=0), origin='lower', cmap='jet')

    return None


def _plot_interpmodel(waves, nw1, nw2, p1, p2):
    '''Plot the diagnostic results of the derive_model function. Four plots
    are generated, showing the normalized interpolation coefficients for the
    blue and red anchors for each WFE realization, as well as the mean trend
    across WFE for each anchor profile, and the resulting polynomial fit to
    the mean trends.

    Parameters
    ----------
    waves : np.array of float
        Wavelengths at which WebbPSF monochromatic PSFs were created.
    nw1 : np.array of float
        Normalized interpolation coefficient for the blue anchor
        for each PSF profile.
    nw2 : np.array of float
        Normalized interpolation coefficient for the red anchor
        for each PSF profile.
    p1 : np.array of float
        Polynomial coefficients of the fit to the mean interpolation
        coefficients for the blue anchor.
    p2 : np.array of float
        Polynomial coefficients of the fit to the mean interpolation
        coefficients for the red anchor.
    '''

    f, ax = plt.subplots(2, 2, figsize=(14, 6))
    for i in range(10):
        ax[0, 0].plot(waves, nw1[i])
        ax[1, 0].plot(waves, nw2[i])

    ax[0, 1].plot(waves, np.mean(nw1, axis=0))
    ax[0, 1].plot(waves, np.mean(nw2, axis=0))

    ax[-1, 0].set_xlabel('Wavelength [µm]', fontsize=14)
    ax[-1, 1].set_xlabel('Wavelength [µm]', fontsize=14)

    y1 = np.polyval(p1, waves)
    y2 = np.polyval(p2, waves)

    ax[1, 1].plot(waves, y1, c='r', ls=':')
    ax[1, 1].plot(waves, y2, c='b', ls=':')
    ax[1, 1].plot(waves, np.mean(nw1, axis=0), c='b', label='Blue Anchor')
    ax[1, 1].plot(waves, np.mean(nw2, axis=0), c='r', label='Red Anchor')
    ax[1, 1].set_xlim(np.min(waves), np.max(waves))
    ax[1, 1].legend(loc=1, fontsize=12)

    f.tight_layout()


def reconstruct_wings(frame, ycen, pad_factor=1):
    '''Takes a reconstructed trace profile which has been truncated about the
    centroid and reconstructs the extended wing structure using an exponential
    profile. Also adds padding in the spatial direction by extending the
    exponetial fit.

    Parameters
    ----------
    frame : np.ndarray of float (2D)
        Empirical trace model.
    ycen : np.array of float
        Y-pixel centroid positions.
    pad_factor : int
        Multiplicative padding factor on the spatial axis. Defaults to 1 (no
        padding).

    Returns
    -------
    newframe : np.ndarray of float (2D)
        Trace model with reconstructed extended wing structure, and required
        padding.
    '''

    # Create new detector array and spatial axis taking into account padding.
    newframe = np.zeros(((pad_factor)*frame.shape[0], frame.shape[1]))
    fullax = np.arange(frame.shape[0])
    fullax_pad = np.arange((pad_factor)*frame.shape[0]) - (frame.shape[0]/2)*(pad_factor-1)

    # Loop over each column on the detector.
    for col in range(frame.shape[1]):

        # Temporary hack for NaN columns
        if np.any(np.isnan(frame[:, col])):
            continue

        # Get the centroid Y-position.
        cen = int(round(ycen[col], 0))

        # Extract the left wing
        start = np.max([0, cen-75])
        ax_l = np.arange(start, cen-9)
        lwing = np.log10(frame[start:(cen-9), col])
        # Find where the log is finite
        lwing_noi = lwing[np.isfinite(lwing)]
        ax_l_noi = ax_l[np.isfinite(lwing)]
        # Fit a first order polynomial to the finite value of the log wing.
        # Equivalent to fitting an exponential to the wing.
        pp_l = np.polyfit(ax_l_noi, lwing_noi, 1)

        # Locate pixels for stitching - where the left wing goes to zero.
        ii_l = np.where(np.isinf(lwing))[0][-1]
        # Location in full axis.
        jj_l = np.where(fullax == ax_l[ii_l])[0][0]
        # Location in padded axis.
        kk_l = np.where(fullax_pad == ax_l[ii_l])[0][0]

        # Extract the right wing
        end = np.min([cen+50, 255])
        ax_r = np.arange(cen+9, end)
        rwing = np.log10(frame[(cen+9):end, col])
        # Find where the log is finite
        rwing_noi = rwing[np.isfinite(rwing)]
        ax_r_noi = ax_r[np.isfinite(rwing)]
        # Fit a first order polynomial to the finite value of the log wing.
        # Equivalent to fitting an exponential to the wing.
        pp_r = np.polyfit(ax_r_noi, rwing_noi, 1)

        # Locate pixels for stitching - where the right wing goes to zero.
        ii_r = np.where(np.isinf(rwing))[0][0]
        jj_r = np.where(fullax == ax_r[ii_r])[0][0]
        kk_r = np.where(fullax_pad == ax_r[ii_r])[0][0]

        # Stitch the wings to the original profile, add padding if necessary.
        newcol = np.concatenate([10**(np.polyval(pp_l, fullax_pad[:kk_l])),
                                 frame[jj_l:jj_r, col],
                                 10**(np.polyval(pp_r, fullax_pad[kk_r:]))])

        try:
            # Find any remaining pixels where the profile is zero.
            inds = np.where(newcol == 0)[0][0]
            # If there are remainining zeros, replace with mean of neighbours.
            newcol[inds] = np.mean([newcol[inds-1], newcol[inds+1]])
        except IndexError:
            pass

        # Renormalize the column.
        newframe[:, col] = newcol / np.nansum(newcol)

    return newframe
