#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jul 20 9:35 2020

@author: MCR

File containing the necessary functions to create a model
interpolated trace in the overlap region for SOSS order 1.
"""

import warnings
warnings.filterwarnings('ignore')
import webbpsf
import numpy as np
from astropy.io import fits
import matplotlib.pyplot as plt
import emcee
import corner
import sys
tppath = '/Users/michaelradica/Documents/GitHub/jwst-mtl/SOSS/trace'
sys.path.insert(1, tppath)
import tracepol as tp


def chromescale(wave, profile, invert=False):
    ''' Utility function to remove the lambda/D chromatic PSF
    scaling by interpolating a monochromatic PSF function onto
    a standard axis.

    Parameters
    ----------
    wave : float
        Wavelength corresponding to the input 1D PSF profile.
    profile : list of floats
        1D PSF profile to be rescaled.
    invert : bool
        If True, add back the lambda/D scaling instead of removing it.

    Returns
    -------
    new : list of floats
        Rescaled 1D PSF profile.
    '''

    # Create the standard axis
    rnge = np.linspace(0, round(49*(2.5/wave), 0) - 1, 49)
    offset = rnge[24] - 24

    # Interpolate the profile onto the standard axis.
    if invert is False:
        new = np.interp(np.arange(49), rnge - offset, profile)
    # Or interpolate the profile from the standard axis to re-add
    # the lambda/D scaling.
    else:
        new = np.interp(rnge - offset, np.arange(49), profile)

    return new


def derive_model(make_psfs=False, doplot=True, F277W=True, filepath=''):
    ''' Function to derive the interpolation coefficients necessary to
    interpolate a monochromatic PSF profile at any wavelength between
    the two 1D PSF anchor profiles.
    If called, it will generate 2D moncochromatic PSF profiles and save
    them to disk if the user does not already have them available.
    This should not need to be called by the end user except in rare cases.

    Parameters
    ----------
    make_psfs : bool
        Whether or not WebbPSF will have to generate the monochromatic
        PSFs used for the fitting.
    doplot : bool
        Whether to show the diagnostic plots for the model derivation.
    F277W : bool
        Does the dataset contain an F277W filter exposure, or only the
        standard CLEAR?
    filepath : str
        Path to directory containing the WebbPSF monochromatic PSF fits
        files, or the directory to which they will be stored when made.
        Defaults to the current directory.

    Returns
    -------
    pb, pr : numpy array
        Array of polynomial coefficients of the interpolation index fits
        for the blue and red anchors respectively.
    wb, wr : numpy array
        Array of precise interpolation coefficients determined for
        each of the monochromatic PSFs for each WFE realization.
    '''

    # Red anchor is 2.8µm without an F277W exposure.
    if F277W is False:
        wave_range = np.linspace(2.2, 2.8, 7)
    # Red anchor is 2.5µm with F277W exposure.
    else:
        wave_range = np.linspace(2.2, 2.5, 7)

    # Read in monochromatic PSFs generated by WebbPSF.
    PSFs = []
    # Loop over all 10 available WFE realizations.
    for i in range(10):
        psf_run = []
        # Create the PSF if user has indicated to.
        if make_psfs is True:
            loicpsf(wavelist=wave_range*1e-6, wfe_real=i)
        # If user already has PSFs generated.
        for w in wave_range:
            try:
                psf_run.append(fits.open('{0:s}SOSS_os10_128x128_{1:.6f}_{2:.0f}.fits'
                                         .format(filepath, w, i))[0].data)
            # Generate missing PSFs if necessary.
            except FileNotFoundError:
                print('No monochromatic PSF found for {0:.1f}µm and WFE realization {1:.0f}.'
                      .format(w, i))
                loicpsf(wavelist=[w*1e-6], wfe_real=i, filepath=filepath)
                psf_run.append(fits.open('{0:s}SOSS_os10_128x128_{1:.6f}_{2:.0f}.fits'
                                         .format(filepath, w, i))[0].data)
        PSFs.append(psf_run)

    # Determine interpolation coefficients for all WFEs
    wb, wr = [], []

    for E in range(10):
        # Generate the blue wavelength anchor.
        # The width of the 1D PSF has lambda/D dependence, so rescale all
        # profiles to a common wavelength to remove these chromatic effects.
        rnge2 = np.linspace(0, round(1280*(2.5/2.2), 0) - 1, 1280)
        offset2 = rnge2[640] - 640
        new2 = np.interp(np.arange(1280), rnge2 - offset2,
                         np.sum(PSFs[E][0][600:700, :], axis=0))

        # Generate the red wavelength anchor.
        if F277W is False:
            # Use 2.8µm for CLEAR.
            rnger = np.linspace(0, round(1280*(2.5/2.8), 0) - 1, 1280)
        else:
            # Or 2.5µm for F277W.
            rnger = np.linspace(0, round(1280*(2.5/2.5), 0) - 1, 1280)
        offsetr = rnger[640] - 640
        # Remove lambda/D scaling.
        newr = np.interp(np.arange(1280), rnger - offsetr,
                         np.sum(PSFs[E][6][600:700, :], axis=0))

        # Loop over all monochrmatic PSFs to determine interpolation coefs.
        for f, wave in enumerate(wave_range):
            # Lists for running counts of indicies and model residuals.
            resid, II, JJ = [], [], []

            # Rescale monochrmotic PSF to remove lambda/D.
            newrnge = np.linspace(0, round(1280*(2.5/wave), 0) - 1, 1280)
            newoffset = newrnge[640] - 640
            newpsf = np.interp(np.arange(1280), newrnge - newoffset,
                               np.sum(PSFs[E][f][600:700, :], axis=0))

            # Brute force the coefficient determination.
            # It should only take a minute or so.
            for i in range(1, 100):
                for j in range(1, 100):
                    I = i / 10
                    J = j / 10
                    # Create a test profile which is a mix of the two anchors.
                    mix = (I*new2 + J*newr) / (I + J)

                    # Save current iteration in running counts.
                    resid.append(np.sum(np.abs(newpsf - mix)[450:820]))
                    II.append(I)
                    JJ.append(J)

            # Determine which combination of indices minimizes model residuals.
            ind = np.where(resid == np.min(resid))[0][0]
            # Save the normalized indices for this wavelength.
            wb.append(II[ind] / (II[ind] + JJ[ind]))
            wr.append(JJ[ind] / (II[ind] + JJ[ind]))

    wb = np.reshape(wb, (10, 7))
    wr = np.reshape(wr, (10, 7))

    # Fit a second order polynomial to the mean of the interpolation indices.
    pb = np.polyfit(wave_range, np.mean(wb, axis=0), 2)
    pr = np.polyfit(wave_range, np.mean(wr, axis=0), 2)

    # Show the diagnostic plot if necessary.
    if doplot is True:
        plot_interpmodel(wave_range, wb, wr, pb, pr)

    return pb, pr, wb, wr


def do_emcee(xOM, yOM, xCV, yCV):
    ''' Utility function which calls the emcee package to preform
    an MCMC determination of the best fitting rotation angle/center to
    map the OM onto the data.

    Parameters
    ----------
    xOM, yOM : array of floats
        X and Y trace centroids respectively in the optics model system,
        for example: returned by get_om_centroids.
    xCV, yCV : array of floats
        X and Y trace centroids determined from the data, for example:
        returned by get_o1_data_centroids.

    Returns
    -------
    sampler : emcee EnsembleSampler object
        MCMC fitting results.
    '''

    # Set up the MCMC run.
    initial = np.array([1, 1577, 215])  # Initial guess parameters
    pos = initial + 0.5*np.random.randn(32, 3)
    nwalkers, ndim = pos.shape

    sampler = emcee.EnsembleSampler(nwalkers, ndim, log_probability,
                                    args=[xOM, yOM, xCV, yCV])
    # Run the MCMC for 5000 steps - it has generally converged
    # within ~3000 steps in trial runs.
    sampler.run_mcmc(pos, 5000, progress=False)

    return sampler


def get_o1_data_centroids(stack, atthesex=None):
    ''' Determine the x, y positions of the order 1 trace centroids from an
    exposure using a center-of-mass analysis.
    This is an adaptation of Loïc's get_order1_centroids which can better
    deal with a bright second order.

    Parameters
    ----------
    stack : numpy array of floats
        Data frame.
    atthesex : list of floats
        Pixel x values at which to extract the trace centroids.

    Returns
    -------
    tracexbest : list of floats
        Best estimate data x centroid.
    traceybest : list of floats
        Best estimate data y centroids.
    '''

    # Dimensions of the subarray.
    dimx = len(atthesex)
    dimy = np.shape(stack)[0]

    # Identify the floor level of all 2040 working pixels to subtract it first.
    floorlevel = np.nanpercentile(stack, 10, axis=0)
    backsubtracted = stack*1
    for i in range(dimx-8):
        backsubtracted[:, i] = stack[:, i] - floorlevel[i]

    # Find centroid - first pass, use all pixels in the column.
    tracex = []
    tracey = []
    row = np.arange(dimy)
    for i in range(dimx - 8):
        val = backsubtracted[:, i + 4] / np.nanmax(backsubtracted[:, i + 4])
        ind = np.where(np.isfinite(val))
        thisrow = row[ind]
        thisval = val[ind]
        cx = np.sum(thisrow * thisval) / np.sum(thisval)
        tracex.append(i + 4)
        tracey.append(cx)

    # Adopt these trace values as best
    tracex_best = np.array(tracex) * 1
    tracey_best = np.array(tracey) * 1

    # Second pass, find centroid on a subset of pixels
    # from an area around the centroid determined earlier.
    tracex = []
    tracey = []
    row = np.arange(dimy)
    w = 30
    for i in range(dimx - 8):
        miny = np.int(np.nanmax([np.around(tracey_best[i] - w), 0]))
        maxy = np.int(np.nanmax([np.around(tracey_best[i] + w), dimy - 1]))
        val = backsubtracted[miny:maxy, i + 4] / np.nanmax(backsubtracted[:, i + 4])
        ind = np.where(np.isfinite(val))
        thisrow = (row[miny:maxy])[ind]
        thisval = val[ind]
        cx = np.sum(thisrow * thisval) / np.sum(thisval)

        # For a bright second order, it is likely that the centroid at this
        # point will be somewhere in between the first and second order.
        # If this is the case (i.e. the pixel value of the centroid is very low
        # compared to the column average), restrict the range of pixels
        # considered to be above the current centroid.
        if backsubtracted[int(cx)][i+4] < np.nanmean(backsubtracted[(int(cx) - w):(int(cx)+w), i+4]):
            miny = np.int(np.nanmax([np.around(cx), 0]))
            maxy = np.int(np.nanmin([np.around(cx + 2*w), dimy - 1]))
            val = backsubtracted[miny:maxy, i + 4] / np.nanmax(backsubtracted[:, i + 4])
            ind = np.where(np.isfinite(val))
            thisrow = (row[miny:maxy])[ind]
            thisval = val[ind]
            cx = np.sum(thisrow * thisval) / np.sum(thisval)

            tracex.append(i + 4)
            tracey.append(cx)

        else:
            tracex.append(i + 4)
            tracey.append(cx)

    # Adopt these trace values as best.
    tracex_best = np.array(tracex) * 1
    tracey_best = np.array(tracey) * 1

    # Third pass - fine tuning.
    tracex = []
    tracey = []
    row = np.arange(dimy)
    w = 16
    for i in range(dimx - 8):
        miny = np.int(np.nanmax([np.around(tracey_best[i] - w), 0]))
        maxy = np.int(np.nanmax([np.around(tracey_best[i] + w), dimy - 1]))
        val = backsubtracted[miny:maxy, i + 4] / np.nanmax(backsubtracted[:, i + 4])
        ind = np.where(np.isfinite(val))
        thisrow = (row[miny:maxy])[ind]
        thisval = val[ind]
        cx = np.sum(thisrow * thisval) / np.sum(thisval)

        tracex.append(i + 4)
        tracey.append(cx)

    tracex_best = np.array(tracex)
    tracey_best = np.array(tracey)

    return tracex_best, tracey_best


def get_o2_data_centroids(clear, return_o1=False):
    ''' Get the order 2 trace centroids via fitting the optics model
    to the first order, and using the known relationship between the
    positions of the first and second orders.

    Parameters
    ----------
    clear : np.ndarray
        CLEAR SOSS exposure data frame.
    return_o1 : bool
        Whether to include the order 1 centroids in the returned value

    Returns
    -------
    xM2 : list
        X-centroids for the order 2 trace.
    yM2 : list
        y-centroids for the order 2 trace.
    xM1 : list (optional)
        x-centroids for the order 1 trace.
    yM1 : list (optional)
        y-centroids for the order 1 trace.

    '''

    # Determine optics model centroids for both orders
    # as well as order 1 data centroids
    atthesex = np.arange(2048)
    xOM1, yOM1, tp1 = get_om_centroids(atthesex)
    xOM2, yOM2, tp2 = get_om_centroids(atthesex, order=2)
    xCV, yCV = get_o1_data_centroids(clear, atthesex)

    # Fit the OM to the data for order 1
    AA = do_emcee(xOM1, yOM1, xCV, yCV)

    # Get fitted rotation parameters
    flat_samples = AA.get_chain(discard=500, thin=15, flat=True)
    ang = np.percentile(flat_samples[:, 0], 50)
    xanch = np.percentile(flat_samples[:, 1], 50)
    yanch = np.percentile(flat_samples[:, 2], 50)

    # Get rotated OM centroids for order 2
    xM2, yM2 = rot_om2det(ang, xanch, yanch, xOM2, yOM2, order=2, bound=True)
    # Ensure that the second order centroids cover the whole detector
    aa = np.polyfit(xM2, yM2, 10)
    yM2 = np.polyval(aa, atthesex)
    inds = np.where((yM2 >= 0) & (yM2 < 256))[0]
    # Also return order 1 centroids if necessary
    if return_o1 is True:
        xM1, yM1 = rot_om2det(ang, xanch, yanch, xOM1, yOM1, bound=True)
        return atthesex[inds], yM2[inds], xM1, yM1
    else:
        return atthesex[inds], yM2[inds]


def get_om_centroids(atthesex=None, order=1):
    ''' Utility function to get order 1 trace profile centroids from the
    JWST NIRISS SOSS optics model.

    Parameters
    ----------
    atthesex : list of floats
        Pixel x values at which to evaluate the centroid position.
    order : int
        Diffraction order for which to return the optics model solution.

    Returns
    -------
    xOM : list of floats
        Optics model x centroid.
    yOM : list of floats
        Optics model y centroids.
    tp2 : list of floats
        trace polynomial coefficients.
    '''

    if atthesex is None:
        atthesex = np.linspace(0, 2047, 2048)

    # Derive the trace polynomials.
    tp2 = tp.get_tracepars(filename='%s/NIRISS_GR700_trace.csv' % tppath)

    # Evaluate the trace polynomials at the desired coordinates.
    w = tp.specpix_to_wavelength(atthesex, tp2, order, frame='nat')[0]
    xOM, yOM, mas = tp.wavelength_to_pix(w, tp2, order, frame='nat')

    return xOM, yOM[::-1], tp2


def log_likelihood(theta, xvals, yvals, xCV, yCV):
    ''' Definition of the log likelihood. Called by do_emcee.
    '''
    ang, orx, ory = theta
    modelx, modely = rot_om2det(ang, orx, ory, xvals, yvals)

    return -0.5 * np.sum(((xCV[:1000] - modelx[4:1004])**2 + (yCV[:1000] - modely[4:1004])**2)
                         - 0.5 * np.log(2 * np.pi * 1))


def log_prior(theta):
    ''' Definition of the priors. Called by do_emcee.
    '''
    ang, orx, ory = theta

    if -15 <= ang < 15 and -4048 < orx < 4048 and -456 < ory < 456:
        return -1
    else:
        return -np.inf


def log_probability(theta, xvals, yvals, xCV, yCV):
    ''' Definition of the final probability. Called by do_emcee.
    '''
    lp = log_prior(theta)
    if not np.isfinite(lp):
        return -np.inf

    return lp + log_likelihood(theta, xvals, yvals, xCV, yCV)


def loicpsf(wavelist=None, wfe_real=None, filepath=''):
    ''' Utility function which calls the WebbPSF package to create
    monochromatic PSFs for NIRISS SOSS obserations and save them to disk.

    Parameters
    ----------
    wavelist : list
        List of wavelengths (in meters) for which to generate PSFs.
    wfe_real : int
        Index of wavefront realization to use for the PSF (if non-default
        WFE realization is desired).
    filepath : str
        Path to the directory to which the PSFs will be written.
        Defaults to the current directory.

    Returns
    -------
    None : NoneType
        PSFs are written to disk.
    '''

    if wavelist is None:
        # List of wavelengths to generate PSFs for
        wavelist = np.linspace(0.5, 5.2, 95) * 1e-6
    # Dimension of the PSF in native pixels
    pixel = 128
    # Pixel oversampling factor
    oversampling = 10

    # Select the NIRISS instrument
    niriss = webbpsf.NIRISS()

    # Override the default minimum wavelength of 0.6 microns
    niriss.SHORT_WAVELENGTH_MIN = 0.5e-6
    # Set correct filter and pupil wheel components
    niriss.filter = 'CLEAR'
    niriss.pupil_mask = 'GR700XD'

    # Change the WFE realization if desired
    if wfe_real is not None:
        niriss.pupilopd = ('OPD_RevW_ote_for_NIRISS_predicted.fits.gz',
                           wfe_real)

    # Loop through all wavelengths to generate PSFs
    for wave in wavelist:
        print('Calculating PSF at wavelength ',
              round(wave/1e-6, 2), ' microns')
        psf = niriss.calc_psf(monochromatic=wave, fov_pixels=pixel,
                              oversample=oversampling, display=False)

        # Save psf realization to disk
        text = '{0:5f}'.format(wave*1e+6)
        psf.writeto(str(filepath)+'SOSS_os'+str(oversampling)+'_'+str(pixel)
                    + 'x'+str(pixel)+'_'+text+'_'+str(wfe_real)+'.fits',
                    overwrite=True)

    return None


def makemod(clear, F277, do_plots=False, filename=None):
    ''' This creates the full order 1 trace profile model. The region
    contaminated by the second order is interpolated from the CLEAR and F277W
    exposures, or just from the CLEAR exposure and a standard red anchor if
    no F277W exposure is available. This is the main function that the end
    user will call, everything else will be done automatically.

    Parameters
    ----------
    clear : numpy array of floats
        NIRISS SOSS CLEAR exposure dataframe.
    F277 : numpy array of floats
        NIRISS SOSS F277W filter exposure dataframe. If no F277W
        exposure is available, pass None for this parameter.
    do_plots : bool
        Whether to show the diagnostic plots.
    filename : str
        Name of file to which to write the trace model.

    Returns
    -------
    O1frame : numpy array of floats
        Complete interpolated order 1 trace model.
    None : NoneType
        The trace model is written to a file.
    '''

    # Get the centroid positions from the optics model and the data.
    pixels = np.linspace(0, 2047, 2048)+0.5
    xOM, yOM, tp2 = get_om_centroids(atthesex=np.linspace(0, 2047, 2048))  # OM
    xCV, yCV = get_o1_data_centroids(clear, atthesex=pixels)  # data
    # Overplot the data centroids on the CLEAR exposure if necessary
    # to verify accuracy.
    if do_plots is True:
        plot_centroid(clear, xCV, yCV)

    # Use MCMC to brute force find the best fitting angle and rotation center
    # necessary to transform the OM coordinates into the data frame.
    ang_samp = do_emcee(xOM, yOM, xCV, yCV)
    # Show the MCMC results in a corner plot if necessary.
    if do_plots is True:
        plot_corner(ang_samp)
    # The MCMC results have been well behaved in all test cases.
    flat_samples = ang_samp.get_chain(discard=500, thin=15, flat=True)
    ang = np.percentile(flat_samples[:, 0], 50)
    xanch = np.percentile(flat_samples[:, 1], 50)
    yanch = np.percentile(flat_samples[:, 2], 50)

    # Determine the anchor profiles - blue anchor.
    # Note that the X-value returned from the optics model are inverted
    # compared to the UdeM coordinate system. This should be checked for
    # consistency when a stable coordinate system is determined.
    xa2 = int(round(tp.wavelength_to_pix(2.2, tp2, 1)[0], 0))  # OM X @ 2.2µm
    ya2 = int(round(256 - tp.wavelength_to_pix(2.2, tp2, 1)[1], 0))  # OM Y @ 2.2µm
    # Use the rotation map to find the location
    # of the 2.2µm centroids in the data.
    xa2, ya2 = rot_om2det(ang, xanch, yanch, xa2, ya2)
    xa2, ya2 = int(round(xa2, 0)), int(round(ya2, 0))
    # Extract the 2.2µm anchor profile from the data.
    Banch = clear[(ya2-24):(ya2+25), xa2]
    # Remove the lambda/D scaling.
    Banch = chromescale(2.2, Banch)

    # Red anchor.
    if F277 is None:
        # Use a simulated F277W exposure as the 2.8µm anchor
        # if no actual F277W exposure is available. By using a simulated
        # F277W exposure we can be sure that there is no contamination
        # from the second order in the anchor.
        try:
            # This will have to be changed when in a package.
            # I'm also not including it in GitHub atm as its a large-ish
            # fits file and realistically I'll be the only one using this code.
            # Thus I'll just use my local copy.
            stand = fits.open('../simu_F277_CLEAR/f277.fits')[0].data[::-1, :]
        except FileNotFoundError:
            sys.exit('The standard red anchor profile was not found.')
        # Find the appropriate X and Y centroids.
        # The simulation is in the OM coordinate system.
        xa5 = int(round(tp.wavelength_to_pix(2.8, tp2, 1)[0], 0))  # OM X @ 2.8µm
        ya5 = int(round(256 - tp.wavelength_to_pix(2.8, tp2, 1)[1], 0))  # OM Y @ 2.8µm
        # Extract and rescale the 2.8µm profile.
        Ranch = stand[(ya5-24):(ya5+25), xa5]
        Ranch = chromescale(2.8, Ranch)

    else:
        # If there is an F277W exposure available, we only need to
        # interpolate out to 2.5µm, as from 2.5 - 2.8µm we have perfect
        # knowledge of teh order 1 trace from the F277W.
        xa5 = int(round(tp.wavelength_to_pix(2.5, tp2, 1)[0], 0)) # OM X @ 2.5µm
        ya5 = int(round(256 - tp.wavelength_to_pix(2.5, tp2, 1)[1], 0)) # OM Y @ 2.5µm
        xa5, ya5 = rot_om2det(ang, xanch, yanch, xa5, ya5)
        xa5, ya5 = int(round(xa5, 0)), int(round(ya5, 0))
        # Extract and rescale the 2.5µm profile.
        Ranch = F277[(ya5-24):(ya5+25), xa5]
        Ranch = chromescale(2.5, Ranch)

    # The interpolation polynomial coefficients. These have been robust
    # in all the trials I have completed, and the hope is they will be robust
    # for all future observations.
    # They were derived through derive_model, however the end user should never
    # need to call this and rederive these polynomials.
    if F277 is None:
        pb = [1.0311255, -6.81906843, 11.01065922]
        pr = [-1.0311255, 6.81906843, -10.01065922]
    else:
        pb = [2.04327661, -12.90780135, 19.50319999]
        pr = [-2.04327661, 12.90780135, -18.50319999]

    # Create the interpolated order 1 PSF.
    map2D = np.zeros((256, 2048))*np.nan
    # Pixel coordinate at which to start and end the interpolation in OM frame.
    # I would be suprised if these are robust long term and should probably
    # be improved in some way.
    if F277 is None:
        start = 4.5
        rlen = 606
    else:
        start = 307.5
        rlen = 303
    # Create an interpolated 1D PSF at each required position.
    for i in range(rlen):
        cenx_int = start + i
        lmbd = tp.specpix_to_wavelength(cenx_int, tp2, 1)[0]  # Wavelength at each centroid
        ceny_int = 256 - tp.wavelength_to_pix(lmbd, tp2, 1)[1]  # Y centroid at each X

        # Transform the OM centroids onto the detector.
        cenx, ceny = rot_om2det(ang, xanch, yanch, cenx_int, ceny_int)

        # Evaluate the interpolation polynomials at the correct wavelength
        # and construct the interpolated 1D PSF.
        wbi = np.polyval(pb, lmbd)
        wri = np.polyval(pr, lmbd)
        mixint = (wbi*Banch + wri*Ranch)

        # Re-add the lambda/D scaling to the interpolated profile.
        newmint = chromescale(lmbd, mixint, invert=True)

        # Put the interpolated profile on the detector.
        # For whatever reason in the news tracepols implementation all the Y
        # centroids shifted up by ~1 pixel. So subtract 1 to cancel this until
        # the root cause can be determined.
        axis = np.linspace(-24, 24, 49) + ceny - 1
        inds = np.where((axis < 256) & (axis >= 0))[0]
        bear = np.interp(np.arange(256), axis[inds], newmint[inds])

        # Subtract the noisy wing edges.
        map2D[:, int(cenx)] = bear - np.nanpercentile(bear, 2.5)

        # Note detector coordinates of the edges of the interpolated region.
        if i == rlen - 1:
            bend = int(cenx)
        elif i == 0:
            rend = int(cenx)

    # Stitch together the interpolation and data to make the complete
    # order 1 PSF.
    newmap = np.zeros((256, 2048))
    newmap[:, rend:bend] = map2D[:, rend:bend]  # Insert interpolated data
    # Bluer region is known from the CLEAR exposure.
    newmap[:, bend:2048] = clear[:, bend:2048]
    # Insert interpolated data to the red as well if no F277W.
    if F277 is None:
        newmap[:, 0:rend] = map2D[:, 0:rend]
    # Or add on the F277W frame to the red if available.
    else:
        newmap[:, 0:rend] = F277[:, 0:rend]
    # Normalize the profile in each column.
    newmap = newmap / np.nanmax(newmap, axis=0)
    # Create a mask to remove the influence of the second order
    # in the CLEAR data.
    O1frame = mask_order(newmap, xCV, yCV)

    # Write the trace model to disk if requested.
    if filename is not None:
        hdu = fits.PrimaryHDU()
        hdu.data = O1frame
        hdu.writeto('%s.fits' % filename, overwrite=True)
        return None
    # Or return the frame itself.
    else:
        return O1frame


def mask_order(frame, xCV, yCV):
    ''' Create a pixel mask to isolate only the detector pixels
    belonging to a specific diffraction order.

    Parameters
    ----------
    frame : np.array
        Science data frame.
    xCV : np.array
        Data x centroids for the desired order
    yCV : np.array
        Data y centroids for the desired order

    Returns
    -------
    O1frame : np.array
        The input data frame, with all pixels other than those
        within +/- 20 pixels of yCV masked.
    '''

    mask = np.zeros([256, 2048])
    xx = np.round(xCV, 0).astype(int)
    yy = np.round(yCV, 0).astype(int)
    xr = np.linspace(np.min(xx), np.max(xx), np.max(xx)+1).astype(int)

    # Set all pixels within the extent of the order 1 trace to 1 in the mask.
    for xxx, yyy in zip(xr, yy):
        mask[(yyy-21):(yyy+20), xxx] = 1

    O1frame = (mask * frame) / np.nanmax(mask*frame, axis=0)

    return O1frame


def plot_centroid(clear, xCV, yCV):
    ''' Utility function to overplot the trace centroids extracted from
    the data over the data isetfl to verify accuracy. Called by makemod.
    '''
    plt.figure(figsize=(15, 3))
    plt.plot(xCV, yCV, c='black')
    plt.imshow(clear/np.nanmax(clear, axis=0), origin='lower', cmap='jet')

    return None


def plot_corner(sampler):
    ''' Utility function to produce the corner plot
    for the results of do_emcee. Called by makemod.
    '''
    labels = [r"ang", "cenx", "ceny"]
    flat_samples = sampler.get_chain(discard=500, thin=15, flat=True)
    fig = corner.corner(flat_samples, labels=labels)

    return None


def plot_interpmodel(waves, nw1, nw2, p1, p2):
    ''' Utility function to plot the diagnostic results of the
    derive_model function. Four plots will be be generated,
    showing the normalized interpolation coefficients for the blue
    and red anchors for each WFE realization, as well as the mean
    trend across WFE for each anchor profile, and the resulting
    polynomial fit to the mean trends.

    Parameters
    ----------
    waves : array of floats
        Wavelengths at which WebbPSF monochromatic PSFs were created.
    nw1, nw2 : array of floats
        Normalized interpolation coefficient for the blue and red anchor
        respectively determined for each PSF profile.
    p1, p2 : array of floats
        Polynomial coefficients of the fit to the mean interplation
        coefficients for the blue and red anchors respectively.

    Returns
    -------
    None : NoneType
        Plot is displayed on screen.
    '''

    x2 = waves

    f, ax = plt.subplots(2, 2, figsize=(14, 6))
    for i in range(10):
        ax[0, 0].plot(x2, nw1[i])
        ax[1, 0].plot(x2, nw2[i])

    ax[0, 1].plot(x2, np.mean(nw1, axis=0))
    ax[0, 1].plot(x2, np.mean(nw2, axis=0))

    ax[-1, 0].set_xlabel('Wavelength [µm]', fontsize=14)
    ax[-1, 1].set_xlabel('Wavelength [µm]', fontsize=14)

    y1 = np.polyval(p1, x2)
    y2 = np.polyval(p2, x2)

    ax[1, 1].plot(x2, y1, c='r', ls=':')
    ax[1, 1].plot(x2, y2, c='b', ls=':')
    ax[1, 1].plot(x2, np.mean(nw1, axis=0), c='b', label='Blue Anchor')
    ax[1, 1].plot(x2, np.mean(nw2, axis=0), c='r', label='Red Anchor')
    ax[1, 1].set_xlim(np.min(x2), np.max(x2))
    ax[1, 1].legend(loc=1, fontsize=12)

    f.tight_layout()

    return None


def rot_om2det(ang, cenx, ceny, xval, yval, order=1, bound=False):
    ''' Utility function to map coordinates in the optics model
    reference frame, onto the detector reference frame, given
    the correct transofmration parameters.

    Parameters
    ----------
    ang : float
        The rotation angle in degrees CCW.
    cenx, ceny : float
        The X and Y pixel values to use as the center of rotation
        in the optics model coordinate system.
    xval, yval : float
        Pixel X and Y values in the optics model coordinate system
        to transform into the detector frame.
    order : int
        Diffraction order.
    bound : bool
        Whether to trim rotated solutions to fit within the subarray256.

    Returns
    -------
    rot_pix[0], rot_pix[1] : float
        xval and yval respectively transformed into the
        detector coordinate system.
    '''

    # Map OM onto detector - the parameters for this transformation
    # are already well known.
    if order == 1:
        t = 1.5*np.pi / 180
        R = np.array([[np.cos(t), -np.sin(t)], [np.sin(t), np.cos(t)]])
        points1 = np.array([xval - 1535, yval - 205])
        b = R @ points1

        b[0] += 1535
        b[1] += 205

    if order == 2:
        t = 1.8*np.pi / 180
        R = np.array([[np.cos(t), -np.sin(t)], [np.sin(t), np.cos(t)]])
        points1 = np.array([xval - 1347, yval - 141])
        b = R @ points1

        b[0] += 1347
        b[1] += 141

    # Required rotation in the detector frame to match the data.
    t = (ang+0.95)*np.pi / 180
    R = np.array([[np.cos(t), -np.sin(t)], [np.sin(t), np.cos(t)]])

    points1 = np.array([b[0] - cenx, b[1] - ceny])
    rot_pix = R @ points1

    rot_pix[0] += cenx
    rot_pix[1] += ceny

    # Check to ensure all points are on the subarray.
    if bound is True:
        inds = [(rot_pix[1] >= 0) & (rot_pix[1] < 256) & (rot_pix[0] >= 0) &
                (rot_pix[0] < 2048)]

        return rot_pix[0][inds], rot_pix[1][inds]
    else:
        return rot_pix[0], rot_pix[1]
