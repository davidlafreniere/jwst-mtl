import glob
import io
import os
import yaml
import sys
from astropy.time import Time

# you must be in the conda environment 'mirage'

# sys.path.insert(0, '/genesis/jwst/bin/mirage/')

from mirage import imaging_simulator
from mirage.yaml import yaml_generator
from jwst.pipeline import Detector1Pipeline
import subprocess as subprocess
import numpy as np
from datetime import datetime
import aptxml_to_catalogs as loic
import generate_catalog_list as neil


#####################################
# INPUTS
#####################################

pathdir = '/genesis/jwst/userland-ami/loic_mirage_betapic/'
# pathdir = '/data/jwst-ami/data/loic_mirage_betapic/'
# The .xml file was generated by the APT with the export capability.
xml_name = os.path.join(pathdir, 'betapic_2476_short.xml')
# The .pointing file was generated simultaneously from the APT.
pointing_name = os.path.join(pathdir, 'betapic_2476_short.pointing')

simdata_output_directory = '/genesis/jwst/userland-ami/loic_mirage_betapic/'
# simdata_output_directory = '/data/jwst-ami/data/loic_mirage_betapic/'

pav3 = 000
obs_date = '2022-05-30 00:00:00'
reffile_defaults = 'crds'
#datatype = 'linear, raw'
datatype = 'raw'
# ---------------------------------
# Primary properties
# ---------------------------------
# Note set value to None to not set, must have same number of entries
#   in all these fields - can set all to None to not set anything
mod_target_name = ['BETA-PIC']
mod_target_ra = [None]
mod_target_dec = [None]
mod_target_f380m = [3.5]
mod_target_f430m = [3.5]
mod_target_f480m = [3.5]

# ---------------------------------
# Companion properties
# ---------------------------------
# Note must all have same number of entries
# to not add a companion make these an empty list = []

# define the primary names (as appears in xml file)
primary_names = ['BETA-PIC', 'BETA-PIC']
# define companion separations in arcsec
companion_seps = [0.1, 0.5]
# define companion position angles in degrees?
companion_pas = [90, 40]
# define companion delta magnitudes [magnitudes fainter than primary]
companion_dms = [5, 10]

#####################################

# When running this script, first delete all input (and output) files:
# rm -f ?bservation* jw*
# In particular the yaml files.
xxx = subprocess.getoutput('rm -rf '+pathdir+'?bserva* '+pathdir+'jw*')

if False:
    # Here, two things are very important:
    # 1) The target name ('BETA-PIC' or 'PSF-REF') is the target name
    # used in the APT file. Theses catalogues need to refer to those APT names.
    # 2) The various sources can be in different catalogues or in the same.
    # 3) The magnitudes of the sources are defined in that .list file.
    #
    # AB Dor is in field 19 and HD37093 is in field 20 in Kevin's targets.xlsx file
    #catalogues = {'BETA-PIC': {'point_source': os.path.join(ami_example_dir, 'betapic_loic.list')},
    #              'PSF-REF': {'point_source': os.path.join(ami_example_dir, 'betapic_ref.list')}}
    #              'HD-37093': {'point_source': os.path.join(ami_example_dir, 'stars_field19_20_combined_allfilters.list')}}
    catalogues = {'BETA-PIC': {'point_source': os.path.join(pathdir, 'betapic_both.list')},
              'PSF-REF': {'point_source': os.path.join(pathdir, 'betapic_both.list')}}
                #'DISK': {'extended':}} #  I did not find how to call this with extended option

if True:
    # Convert the date to a Time object
    date_object = Time(obs_date, format='iso')
    print('Catalogues for date: ', date_object.iso)

    # Run apt2cat in aptxml_to_catalog.py to generate the list files
    cout = loic.apt2cat(xml_name, date_object.decimalyear)
    catalog_list, target_list, catalog_tables, target_pos = cout

    print('\n\nThe APT xml file was read and these catalogues and target lists '
          'were generated:')
    for it in range(len(catalog_list)):
        print('\t {0}: {1}'.format(target_list[it], catalog_list[it]))

    # -------------------------------------------------------------------------
    for it in range(len(mod_target_name)):
        # get this iterations values
        mod_name = mod_target_name[it]
        mod_ra = mod_target_ra[it]
        mod_dec = mod_target_dec[it]
        mod_f380m = mod_target_f380m[it]
        mod_f430m = mod_target_f430m[it]
        mod_f480m = mod_target_f480m[it]
        # log progress
        print('Modifying primary: {0}'.format(mod_name))
        # get argumetns for modify_primary function
        cargs = [target_list, catalog_tables, target_pos, mod_name,
                 mod_ra, mod_dec, mod_f380m, mod_f430m, mod_f480m]
        # modify to table
        catalog_tables = neil.modify_primary(*cargs, log=True)
    # -------------------------------------------------------------------------
    # loop around sources to add
    for it in range(len(primary_names)):
        # get this iterations values
        primary_name = primary_names[it]
        companion_sep = companion_seps[it]
        companion_pa = companion_pas[it]
        companion_dm = companion_dms[it]
        # log progress
        print('Adding companion to {0}'.format(primary_name))
        # get arguments for add_companion_to_cat_entry function
        cargs = [target_list, catalog_tables, target_pos, primary_name,
                 companion_sep, companion_pa, companion_dm]
        # add companions to table
        catalog_tables = neil.add_companion_to_cat_entry(*cargs)
    # -------------------------------------------------------------------------
    # write catalog tables
    for it, catalog_table in enumerate(catalog_tables):
        neil.write_catalog(catalog_table, outfile=catalog_list[it])
    # -------------------------------------------------------------------------

    # Here, we need to remake a catalogues structure as above containing all catalogs returned
    # by apt2cat(). Neil, please do so. I do not know how to create that structure.
    catalogues = catalog_list
    # Until that is done, use this:
    # catalogues = {'BETA-PIC': {'point_source': os.path.join(pathdir, 'betapic_2476_short_BETA-PIC_catalog.list')},
    #           'PSF-REF': {'point_source': os.path.join(pathdir, 'betapic_2476_short_PSF-REF_catalog.list')}}

if True:

    yam = yaml_generator.SimInput(input_xml=xml_name,
                                  pointing_file=pointing_name,
                                  catalogs=catalogues, roll_angle=pav3,
                                  dates=obs_date,
                                  reffile_defaults=reffile_defaults,
                                  verbose=True,
                                  output_dir=simdata_output_directory,
                                  simdata_output_dir=simdata_output_directory,
                                  datatype=datatype)

    yam.create_inputs()

    # Create all files
    yaml_files = glob.glob(os.path.join(simdata_output_directory, 'jw*.yaml'))
    print(yaml_files)

    for file in yaml_files:

        # set astrometric reference file to None to use pysiaf
        with open(file, 'r') as infile:
            yaml_content = yaml.safe_load(infile)
        yaml_content['Reffiles']['astrometric'] = 'None'
        yaml_content['psf_wing_threshold_file'] = 'config'
        modified_file = file.replace('.yaml', '_mod.yaml')
        with io.open(modified_file, 'w') as outfile:
            yaml.dump(yaml_content, outfile, default_flow_style=False)

        t1 = imaging_simulator.ImgSim()
        t1.paramfile = str(modified_file)
        t1.create()

# Call the first stage DMS
if True:

    # Lists all uncal.fits files
    thecall = 'ls -1 '+pathdir+'jw*nis_uncal.fits'
    ls = subprocess.getoutput(thecall)
    uncal_list = np.array(ls.split('\n'))
    # Forge the list of uncal fits files to send to DMS
    #basename_list = np.copy(uncal_list)
    #for i in range(np.size(uncal_list)):
    #    one, two, three = uncal_list[i].partition('_uncal')
    #    basename_list[i] = one+'_uncal.fits'
    # Launch DMS stage 1 and write results in the same path as uncal images
    # with the name default.
    for i, uncal_filename in enumerate(uncal_list):
        result = Detector1Pipeline.call(uncal_list[i], output_dir=pathdir,
                                        save_results=True)
